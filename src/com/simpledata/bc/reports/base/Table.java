/* Copyright (c) 2003 to 2007 SimpleData Sarl http://simpledata.ch   * All rights reserved. * * This file is part of TariffEye Software  realeased under the  * GNU Public License. Redistributions of source code and binaries  * must retain the above copyright notice; see COPYING_Tariff-Eye.txt  * *//** * @author Simpledata SARL, 2004, all rights reserved.  * @version $Id: Table.java,v 1.2 2007/04/02 17:04:23 perki Exp $ *//** * Package containing all helper classes that form  * the abstract report/subreport tree. This tree * can directly be visited and produced as a report.  */package com.simpledata.bc.reports.base;import java.util.ArrayList;/** * Table that is the basis for the Report datasource.  * This can be any tabular data. Tabular data has rows * and columns: Each row has a number and columns have * names.  * * The columns that contain references to the SubreportTreeItem * interface have names that will be used as a base for the * final Report name: 'Foo' will become 'FooDatasource', 'FooReport',  * 'FooFields' and 'FooShow'.  */class Table {	/** Fields in this table */	private TableFields m_fields; 	/** Data rows in this table */	private ArrayList/*<TableRow>*/ m_rows; 			// Interface for data extraction (package)		/**	 * Retrieve the description of column headers and types. 	 * @return This tables column headers. 	 */	TableFields getColumnHeaders() {		return m_fields;	}		/**	 * Retrieve one data item. 	 * @param row Row index of data.	 * @param cell Cell index of data.	 * @return Jasper field contained at this location. 	 */	Object getNormalCell( int row, int cell ) {		TableRow rowe = (TableRow) m_rows.get( row );		return rowe.getData( cell );	}		/**	 * Retrieve one data item. 	 * @param row Row index of data.	 * @param cell Cell index of data.	 * @return Jasper field contained at this location. 	 */	SubreportTreeItem getReportCell( int row, int cell ) {		TableRow rowe = (TableRow) m_rows.get( row );		return rowe.getReport( cell );	}			/**	 * Construct a table that is initially empty	 * and contains no header definitions. 	 */	public Table() {		m_fields = new TableFields();		m_rows = new ArrayList(); 	}		// Proxy to TableFields -------------------------------	// Construction of Table header. 		/** 	 * Add a normal Jasper type field. Jasper types include: 	 * String, Object, Boolean, Byte, Date, Timestamp, Time, 	 * Double, Float, Integer, InputStream, Long, Short, 	 * BigDecimal.	 * Proxy to TableFields. 	 */	public void addJasperField( String name ) {		m_fields.addJasperField( name ); 	}		/**	 * Add a report field. These will 	 * be expanded with the three postfixes 'Show', 'Report', 'Fields'   * and 'Datasource' on the Jasper level. The only value that 	 * you can store in a field like this is an implementor of 	 * SubreportTreeItem. 	 * 	 * Proxy to TableFields.	 */	public void addReportField( String name ) {		m_fields.addReportField( name ); 	}		/**	 * Call this once your field definition is stable 	 * (meaning finished). This will forbid addition 	 * of further fields. 	 * 	 * Proxy to TableFields.	 */	public void freezeDefinitions() {		m_fields.freeze();	}		/**	 * Create a simple Table by express addition of all 	 * Strings in the Array. 	 * @param ary Strings to add as Jasper fields. 	 */	public void addJasperFields( final String[] ary ) {		assert ary != null && ary.length > 0 : 			"Array must not be null or empty."; 				for (int i=0; i<ary.length; ++i) {			addJasperField(ary[i]); 		}	}		/**	 * Query the number of fields this table has. See also 	 * the functions that query Jasper level table data. 	 * @return number of columns for this table. 	 */	public int columns() {		return m_fields.size(); 	}		/**	 * Return number of data rows stored in this table. 	 * @return number of rows available here. 	 */	public int rows() {		return m_rows.size(); 	}		// Data adding ----------------------------------------		/**	 * Add one full row of data. The data passed in 	 * here must be of the proper types, only rudimentary 	 * checking is done. 	 *	 * The recommended way to use this is to derive from 	 * Subreport and implement an addDataRow method that	 * has the correct number and type of arguments and then	 * add all of those arguments via this method into the 	 * table internally. 	 * @param ary The data to add to this report. 	 */	public void addDataRow( final Object[] ary ) {		TableRow row = new TableRow( m_fields ); 				assert ary.length == this.columns() : 			"Added data must have correct number of columns."; 				for (int i=0; i<ary.length; ++i) {			row.put( i, ary[i] ); 		}		m_rows.add( row ); 	}			}
/* Copyright (c) 2003 to 2007 SimpleData Sarl http://simpledata.ch  
 * All rights reserved.
 *
 * This file is part of TariffEye Software  realeased under the 
 * GNU Public License. Redistributions of source code and binaries 
 * must retain the above copyright notice; see COPYING_Tariff-Eye.txt 
 *
 */

package com.simpledata.bc.reports.tarification;

import java.text.StringCharacterIterator;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import org.apache.log4j.Logger;

import com.simpledata.bc.components.TarifTreeItem;
import com.simpledata.bc.components.TarifTreeVisitor;
import com.simpledata.bc.components.bcoption.OptionBoolean;
import com.simpledata.bc.components.bcoption.OptionCase;
import com.simpledata.bc.components.bcoption.OptionCommissionAmountUnder;
import com.simpledata.bc.components.bcoption.OptionDoublePositive;
import com.simpledata.bc.components.bcoption.OptionMoneyAmount;
import com.simpledata.bc.components.bcoption.OptionMoneyAmountUnder;
import com.simpledata.bc.components.bcoption.OptionNaturalInteger;
import com.simpledata.bc.components.bcoption.OptionPerBaseTen;
import com.simpledata.bc.components.bcoption.OptionSimple;
import com.simpledata.bc.components.bcoption.tools.LinkToTarifs;
import com.simpledata.bc.components.worksheet.dispatcher.AssetsRoot0;
import com.simpledata.bc.components.worksheet.dispatcher.DispatcherBounds;
import com.simpledata.bc.components.worksheet.dispatcher.DispatcherCase;
import com.simpledata.bc.components.worksheet.dispatcher.DispatcherIf;
import com.simpledata.bc.components.worksheet.dispatcher.DispatcherSequencer;
import com.simpledata.bc.components.worksheet.dispatcher.DispatcherSimple;
import com.simpledata.bc.components.worksheet.dispatcher.FuturesRoot0;
import com.simpledata.bc.components.worksheet.dispatcher.TransactionsRoot0;
import com.simpledata.bc.components.worksheet.workplace.EmptyWorkSheet;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceAssetsRateBySlice;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceFixedFee;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceFutFeeBySlice;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceRateBySliceOnAmount;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceRateOnAmount;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceSimple;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceTrRateBySlice;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceTransferOptions;
import com.simpledata.bc.components.worksheet.workplace.WorkPlaceWithOnlyOptions;
import com.simpledata.bc.components.worksheet.workplace.tools.FeeBySlice;
import com.simpledata.bc.components.worksheet.workplace.tools.RateBySlice;
import com.simpledata.bc.datamodel.BCOption;
import com.simpledata.bc.datamodel.Dispatcher;
import com.simpledata.bc.datamodel.Tarif;
import com.simpledata.bc.datamodel.WorkSheet;
import com.simpledata.bc.datamodel.calculus.ReducOrFixed;
import com.simpledata.bc.datamodel.money.Money;
import com.simpledata.bc.reports.base.RenderEventManager;
import com.simpledata.bc.reports.base.SubreportTreeItem;
import com.simpledata.bc.reports.common.ReportRenderContext;
import com.simpledata.bc.reports.common.SectionNumber;
import com.simpledata.bc.tools.Lang;
import com.simpledata.bc.tools.OrderedMapOfStrings;
import com.simpledata.bc.uicomponents.worksheet.workplace.tools.FeeBySlicePanel;
import com.simpledata.bc.uicomponents.worksheet.workplace.tools.RateBySlicePanel;



/**
 * TarifReportConstructor implements a visitor to visit
 * all contents of a Tarif. Subreports are constructed recursivly
 * while visit and are returned to the caller. 
 *
 * It is used by the CompactNodeLinearizer to construct the
 * content of all sections. 
 *
 * @version $Id: TarifReportConstructor.java,v 1.2 2007/04/02 17:04:28 perki Exp $
 * @author Simpledata SARL, 2004, all rights reserved. 
 */
class TarifReportConstructor implements TarifTreeVisitor {
    
    private static final Logger m_log = 
        Logger.getLogger( TarifReportConstructor.class ); 
	
    
	/** Name of the report generated by this class */
	public static final String REPORTNAME = "tarification";
	
	/** Indexes for title */
	private static final String ALPHABETTA = "abcdefghijklmnopqrstuvwxyz";
		
	/** Resulting worksheet from tree recursion. */
	private SubreportTreeItem m_result;
	/** Context of report rendering */
	private ReportRenderContext m_context; 
	
	/**
	 * Recurse into the TarifTreeItem given as parameter. This is 
	 * a helper class that permits having a result floating up 
	 * the tree. <br>
	 * This method also produces the discount subreport, it indicates
	 * if the worksheet has a discount or not.
	 * 
	 * @param tree Tree to recurse into. 
	 * @return Subreport that describe the children under this node 
	 *         or null if there was no subreport produced. 
	 */
	private SubreportTreeItem recurse( TarifTreeItem tree ) {
		m_result = null;
		// produce subreport
		tree.visit( this );
		
		// Look for Discount
		WorkSheet ws = (WorkSheet) tree;
		ReducOrFixed rof = ws.getReductionOrFixed();
		if (rof != null) {
			// Tariff with discount
			StringBuffer discountInfo = new StringBuffer();
			discountInfo.append(Lang.translate("Applied discount: "));
			double rate = rof.getReduRate() * 100;
			if (rate != 0.0) {
				// pro rata
				discountInfo.append(rate+" %.");
			}
			double min = rof.getMin();
			String currency = rof.getCurrency().toString();
			if (min != 0.0) {
				// with minimum
				discountInfo.append(" "+Lang.translate(
						"Minimal perceived fee: "));
				discountInfo.append(min+" "+currency+".");
			}
			double max = rof.getMax();
			if (max != -1.0) {
				// with maximal
				discountInfo.append(" "+Lang.translate(
						"Maximal perceived fee: "));
				discountInfo.append(min+" "+currency+".");
			}
			m_result = new SubreportDiscount(m_context.getEventManager(), 
					REPORTNAME, discountInfo.toString(), m_result).getReport();
		}
		
		//~ assert m_result != null : 
			//~ "Tree recurse result cannot be null"; 
		
		return m_result;
	}
	
	/**
	 * Recurse into the List of TarifTreeItems and return all 
	 * the results in the form of an list. Array ordering is 
	 * respected. 
	 * @param worksheets List of TarifTreeItems to produce subreports for. 
	 * @return List of SubreportTreeItems to include in current 
	 *         report. 
	 */
	private SubreportTreeItem[] recurse( List/*<TarifTreeItem>*/ worksheets ) {
		assert worksheets != null : 
			"worksheets cannot be null"; 
		
		SubreportTreeItem[] results = new SubreportTreeItem[ worksheets.size() ];
		Iterator it = worksheets.listIterator();

		// iterate over all the items in the worksheets list
		for (int i=0; i<results.length; ++i) {
			TarifTreeItem ti = (TarifTreeItem) it.next(); 
			
			results[i] = recurse( ti );
		}
		
		return results;
	}
	
	private SubreportSingleOption produceOptionReport(BCOption option) {
		SubreportSingleOption result = null;
		RenderEventManager ctx = m_context.getEventManager();
		String name = option.getTitle();
		
		if (option instanceof OptionBoolean) {
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Simple choice:"), name);
		} else if (option instanceof OptionCase) {
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Multiple choice:"), name);
			OrderedMapOfStrings omos = ((OptionCase)option).getCases();
			ArrayList /*<String>*/ al = omos.getXObjects();
			Iterator it = al.iterator();
			while (it.hasNext()) {
				String aCase = (String)it.next();
				SubreportSingleOption.DataRow row = result.produceDataRow();
				row.details = (it.hasNext()) ? aCase+" "+Lang.translate("or")
											 : aCase;
				result.addData(row);
			}
		} else if (option instanceof OptionDoublePositive) {
			String value = ((OptionDoublePositive)option).getValue();
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Constant value:"), name);
			SubreportSingleOption.DataRow row = result.produceDataRow();
			row.details = value;
			result.addData(row);
		} else if (option instanceof OptionMoneyAmount) {
			Money value = ((OptionMoneyAmount)option).moneyValue(null);
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Constant money amount:"),name);
			SubreportSingleOption.DataRow row = result.produceDataRow();
			row.details = value.toString();
			result.addData(row);
		} else if (option instanceof OptionNaturalInteger) {
			String value = ((OptionNaturalInteger)option).getValue();
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Constant value:"),name);
			SubreportSingleOption.DataRow row = result.produceDataRow();
			row.details = value;
			result.addData(row);
		} else if (option instanceof OptionPerBaseTen) {
			String value = ((OptionPerBaseTen)option).getValue(); // XXX change for devider
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Constant rate:"),name);
			SubreportSingleOption.DataRow row = result.produceDataRow();
			row.details = value;
			result.addData(row);
		} else if (option instanceof OptionSimple) {
			result = new SubreportSingleOption(ctx, REPORTNAME,
					Lang.translate("Constant name:"),name);
		} else {
			// Assuming others are irrelevant information
			m_log.warn("An uninplemented irrelevant " +
				"option description is required: "+option.getClass());
		}
		
		return result;
	}
	/**
	 * Constructs a report constructor for a Tarif. 
	 * 
	 * @param ctx Context for rendering. 
	 */
	TarifReportConstructor( ReportRenderContext ctx ) {
		m_context = ctx; 
	}
	
	/**
	 * Visit the tarif and construct the subreport that describes
	 * it. 
	 * @param tarif Tarif to visit.
	 */
	SubreportTreeItem consumeTarif( Tarif tarif ) {
		WorkSheet ws = tarif.getWorkSheet();
		
		return recurse( (TarifTreeItem) ws );
	}
	
	// TarifTreeVisitor implementation ----------------------------
	
	  /**
     * @see TarifTreeVisitor#caseWorkPlaceRateBySliceOnAmount(WorkPlaceRateBySliceOnAmount)
     */
    public void caseWorkPlaceRateBySliceOnAmount(WorkPlaceRateBySliceOnAmount node) {
    	String currency; 
		SubreportRateBySliceOnAmount report;
		RateBySlice rbs = node.getRbs();

		assert rbs != null : 
			"RateBySlice member cannot be null";
		
		// get the currency
		currency = rbs.getCurrency().toString();
		
		// get how the amount is refered
		ArrayList options = node.getOptions();
		assert options.size() == 1 : "RateBySliceOnAmount should have a single option";
		
		Object option = options.get(0);
		m_log.debug ("option is type :"+option.getClass());
		StringBuffer reference = new StringBuffer();
		reference.append(" ");
		if (option instanceof OptionMoneyAmount) {
			OptionMoneyAmount oma = (OptionMoneyAmount) option;
			Money value = oma.moneyValue(null);
			reference.append(Lang.translate("Fixed amount: "+value));
		} else if (option instanceof LinkToTarifs) { // Money Amount Under or
													 // Commission Amount Under
			if (option instanceof OptionMoneyAmountUnder)
				reference.append(Lang.translate("Sum of assets of "));
			else if (option instanceof OptionCommissionAmountUnder)
				reference.append(Lang.translate("Sum of commissions of "));
			
			// TODO Use a better way to reprazent the linked tarifs
			
			LinkToTarifs ltt = (LinkToTarifs) option;
			List tarifs = ltt.getLinkedTarifs();
			ListIterator tit = tarifs.listIterator();
			
			while ( tit.hasNext() ) {
				Object o = tit.next();
				assert o instanceof Tarif : "Must be a list of Tarifs."; 
				Tarif t = (Tarif) o; 
				reference.append (t.getTitle());
				//String link = m_context.getLinkFor(t,"").toString();
				///reference.append("("+link+")");
				if (tit.hasNext())
					reference.append (", ");
			}
		}
		report = new SubreportRateBySliceOnAmount( 
			m_context.getEventManager(), 
			REPORTNAME,  
			rbs.getIsMarginalRate(), 
			currency,
			reference.toString()
		);
		
		// construct UI representation of rbs and retrieve table
		// model
		RateBySlicePanel panel = new RateBySlicePanel( rbs, null );
		
		assert panel.getTableColumnCount() == 4 : 
			"Data model must have 4 columns";
		
		int rows = panel.getTableRowCount();
		for (int row=0; row<rows; ++row) {
			SubreportRateBySliceOnAmount.DataRow drow = report.produceDataRow();

			drow.startValue = ( panel.getValueAtX( row, 0 ) ).toString();
			drow.margRate   = ( panel.getValueAtX( row, 1 ) ).toString();
			drow.effRate    = ( panel.getValueAtX( row, 2 ) ).toString();
			drow.minFee     = ( panel.getValueAtX( row, 3 ) ).toString();
			
			report.addData( drow );
		}
		
		m_result = report.getReport();
    }
	
    /**
     * @see TarifTreeVisitor#caseFuturesRoot0(FuturesRoot0)
     */
    public void caseFuturesRoot0(FuturesRoot0 node) {
    	/*
    	// get result of reporting children.
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		
		Iterator it = children.listIterator();
		SubreportDispSequencer report = new SubreportDispSequencer( m_context.getEventManager(), REPORTNAME );
		for (int i=0; i<subreports.length; ++i) {
			WorkSheet childws = (WorkSheet) it.next();
			SubreportDispSequencer.DataRow row = report.produceDataRow();
			
			row.title = childws.getTitle();
			row.subreport = subreports[i];
			
			report.addData( row );
		}
		
		m_result = report.getReport();
		*/
    	List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert subreports.length <= 1 : "An futures root workplace should have a single child";
		if (subreports.length == 1)
			m_result = subreports[0];
    }
    
    /**
     * @see TarifTreeVisitor#caseFuturesRoot0(FuturesRoot0)
     */
    public void caseWorkPlaceFutFeeBySlice(WorkPlaceFutFeeBySlice node) {
        String currency; 
		int appliesTo;
		SubreportFutFeeBySlice report;
		FeeBySlice fbs = node.getFbs();

		assert fbs != null : 
			"FeeBySlice member cannot be null";
		
		currency = fbs.getMinimum().getCurrency().toString();
		appliesTo = node.getApplyOn();
		
		report = new SubreportFutFeeBySlice( 
			m_context.getEventManager(), 
			REPORTNAME, 
			currency,
			appliesTo
		);
		
		// construct UI representation of rbs and retrieve table
		// model
		FeeBySlicePanel panel = new FeeBySlicePanel( fbs, null );
		
		assert panel.getTableColumnCount() == 2 : 
			"Data model must have 2 columns";
		
		int rows = panel.getTableRowCount();
		for (int row=0; row<rows; ++row) {
			SubreportFutFeeBySlice.DataRow drow = report.produceDataRow();

			drow.startValue = ( panel.getValueAtX( row, 0 ) ).toString();
			drow.fee        = ( panel.getValueAtX( row, 1 ) ).toString();
			
			report.addData( drow );
		}
		
		m_result = report.getReport();
    }
    
    
	// all workplaces
	public void caseWorkPlaceWithOnlyOptions( WorkPlaceWithOnlyOptions node ) {
		// Produce the list of options
		SubreportOptionsList report =
			new SubreportOptionsList(m_context.getEventManager(), REPORTNAME);
		ArrayList /*<BCOption>*/ options = node.getOptions();
		Iterator it = options.iterator();
		while (it.hasNext()) {
			BCOption anOption = (BCOption)it.next();
			// produce option report and add it to the list
			SubreportSingleOption sso = produceOptionReport(anOption);
			if (sso != null) { // null case happens until some options are hiden
				SubreportOptionsList.DataRow row = report.produceDataRow();
				row.singleOption = sso.getReport();
				report.addData(row);
			}
		}
		
		m_result = report.getReport();
	}
	
	public void caseWorkPlaceTransferOptions( WorkPlaceTransferOptions node ) {
		// TODO link
		SubreportTextOnly report;
		Tarif referedTarif = node.getSingleParentTarif();
		SectionNumber link = m_context.sectionNumber(referedTarif);
		String args[] = {referedTarif.getTitle(), link.toString()};
		String text = 
			Lang.translate("The tariff ' %0 ' (%1) is applied for this WorkPlace", args);
		report = new SubreportTextOnly(m_context.getEventManager(), REPORTNAME, text);
		m_result = report.getReport();
	}
	
	public void caseWorkPlaceTrRateBySlice( WorkPlaceTrRateBySlice node ) {
		String currency; 
		int appliesTo;
		SubreportTrRateBySlice report;
		RateBySlice rbs = node.getRbs();

		assert rbs != null : 
			"RateBySlice member cannot be null";
		
		currency = rbs.getCurrency().toString();
		appliesTo = node.getApplyOn();
		int method = node.getCalculusMethod();
		
		report = new SubreportTrRateBySlice( 
			m_context.getEventManager(), 
			REPORTNAME, 
			appliesTo, 
			method,
			rbs.getIsMarginalRate(), 
			currency
		);
		
		// construct UI representation of rbs and retrieve table
		// model
		RateBySlicePanel panel = new RateBySlicePanel( rbs, null );
		
		assert panel.getTableColumnCount() == 4 : 
			"Data model must have 4 columns";
		
		int rows = panel.getTableRowCount();
		for (int row=0; row<rows; ++row) {
			SubreportTrRateBySlice.DataRow drow = report.produceDataRow();

			drow.startValue = ( panel.getValueAtX( row, 0 ) ).toString();
			drow.margRate   = ( panel.getValueAtX( row, 1 ) ).toString();
			drow.effRate    = ( panel.getValueAtX( row, 2 ) ).toString();
			drow.minFee     = ( panel.getValueAtX( row, 3 ) ).toString();
			
			report.addData( drow );
		}
		
		m_result = report.getReport();
	}
	public void caseWorkPlaceSimple( WorkPlaceSimple node ) {
		// should not be reported
	}
	public void caseWorkPlaceAssetsRateBySlice( WorkPlaceAssetsRateBySlice node ) {
		String currency; 
		int appliesTo;
		SubreportAssetsRateBySlice report;
		RateBySlice rbs = node.getRbs();

		assert rbs != null : 
			"RateBySlice member cannot be null";
		
		currency = rbs.getCurrency().toString();
		appliesTo = node.getPerAmount().booleanValue() ? 0 : 1;
		
		report = new SubreportAssetsRateBySlice( 
			m_context.getEventManager(), 
			REPORTNAME, 
			appliesTo, 
			rbs.getIsMarginalRate(), 
			currency
		);
		
		// construct UI representation of rbs and retrieve table
		// model
		RateBySlicePanel panel = new RateBySlicePanel( rbs, null );
		
		assert panel.getTableColumnCount() == 4 : 
			"Data model must have 4 columns";
		
		int rows = panel.getTableRowCount();
		for (int row=0; row<rows; ++row) {
			SubreportAssetsRateBySlice.DataRow drow = report.produceDataRow();

			drow.startValue = ( panel.getValueAtX( row, 0 ) ).toString();
			drow.margRate   = ( panel.getValueAtX( row, 1 ) ).toString();
			drow.effRate    = ( panel.getValueAtX( row, 2 ) ).toString();
			drow.minFee     = ( panel.getValueAtX( row, 3 ) ).toString();
			
			report.addData( drow );
		}
		
		m_result = report.getReport();
	}
	public void caseWorkPlaceRateOnAmount( WorkPlaceRateOnAmount node ) {
		SubreportRateOnAmount report = new SubreportRateOnAmount( 
			m_context.getEventManager(), 
			REPORTNAME
		);
		
		List optionList = node.getOptions();
		
		assert optionList != null : 
			"Option list cannot be null by contract.";
		
		ListIterator it = optionList.listIterator();
		while ( it.hasNext() ) {
			BCOption opt = (BCOption) it.next();
			
			if ( opt instanceof OptionPerBaseTen ) {
				OptionPerBaseTen rate = (OptionPerBaseTen) opt;
				
				report.setRate( rate.toString() );
			} 
			else if ( opt instanceof OptionMoneyAmount ) {
				OptionMoneyAmount oma = (OptionMoneyAmount) opt; 
				Money amount = oma.moneyValue(null);
				
				SubreportRateOnAmount.DataRow row = report.produceDataRow();
				String[] args = {oma.getTitle(), amount.toString()};
				row.amountOrReference = 
					Lang.translate( " on Amount %0 = %1" , args);
				
				report.addData( row );
			}
			else if ( opt instanceof OptionMoneyAmountUnder ) {
				OptionMoneyAmountUnder amountlist = (OptionMoneyAmountUnder) opt; 
				List tarifs = amountlist.getLinkedTarifs();
				assert tarifs != null : "Tarifs list cannot be null.";
				// Tarifs ITerator, I swear
				ListIterator tit = tarifs.listIterator();
				
				while ( tit.hasNext() ) {
					Object o = tit.next();
					assert o instanceof Tarif : "Must be a list of Tarifs."; 
					Tarif t = (Tarif) o; 
					
					SubreportRateOnAmount.DataRow row = report.produceDataRow();
					SectionNumber link = m_context.sectionNumber(t);
					if (link != null)
						row.amountOrReference = Lang.translate( "Amount from Tarif: " )+
						t.getTitle()+" ("+link+")";
					report.addData( row );
				}
			}  // moneyamountunder
			else if ( opt instanceof OptionCommissionAmountUnder ) {
				OptionCommissionAmountUnder amountlist = (OptionCommissionAmountUnder) opt; 
				List tarifs = amountlist.getLinkedTarifs();
				assert tarifs != null : "Tarifs list cannot be null.";
				// Tarifs ITerator, I swear
				ListIterator tit = tarifs.listIterator();
				
				while ( tit.hasNext() ) {
					Object o = tit.next();
					assert o instanceof Tarif : "Must be a list of Tarifs."; 
					Tarif t = (Tarif) o; 
					
					SubreportRateOnAmount.DataRow row = report.produceDataRow();
					SectionNumber link = m_context.sectionNumber(t);
					if (link != null)
						row.amountOrReference = Lang.translate( "Commission from Tarif: " )+
						t.getTitle()+" ("+link+")";
					report.addData( row );
				}
			}  // commissionamountunder
		}
		
		m_result = report.getReport();
	}
	public void caseWorkPlaceFixedFee( WorkPlaceFixedFee node ) {
		Money fee = node.getMyFee();
		SubreportFixedFee report = new SubreportFixedFee( m_context.getEventManager(), REPORTNAME, fee.toString() );
		m_result = report.getReport();
	}
	public void caseEmptyWorkSheet( EmptyWorkSheet node ) {
		// empty on purpose
	}
		
	// all dispatchers
	public void caseDispatcherSimple( DispatcherSimple node ) {
		assert false : 
			"As the documentation indicates, WorkplaceWithOnlyOptions should not occur in a normal Tarif";
	}
	public void caseDispatcherSequencer( DispatcherSequencer node ) {
		// get result of reporting children.
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		if (children.size() == 1) {
			// avoid useless disp seq.
			m_result = subreports[0];
		} else {
			
			Iterator it = children.listIterator();
			SubreportDispSequencer report = new SubreportDispSequencer( m_context.getEventManager(), REPORTNAME );
			// description
			String desc = node.getDescription();
			if (!desc.equals(""))
				report.addHeader(desc);
			for (int i=0; i<subreports.length; ++i) {
				WorkSheet childws = (WorkSheet) it.next();
				SubreportDispSequencer.DataRow row = report.produceDataRow();
				String index = ""+(i+1);
				if (childws instanceof Dispatcher &&
					((Dispatcher)childws).getChildWorkSheets().size() > 1) {
					row.title = index + ")";
				} else
					row.title = index+") "+childws.getTitle();
				
				row.subreport = subreports[i];
				
				report.addData( row );
			}
			m_result = report.getReport();
		}
	}
	public void caseDispatcherIf( DispatcherIf node ) {
		// get result of reporting children.
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		String description = node.getDescription();
		
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		
		Iterator it = children.listIterator();
		SubreportDispIf report = new SubreportDispIf( m_context.getEventManager(), REPORTNAME, description );
		for (int i=0; i<subreports.length; ++i) {
			WorkSheet childws = (WorkSheet) it.next();
			SubreportDispIf.DataRow row = report.produceDataRow();
			String index = ""+ALPHABETTA.charAt(i);
			if (childws instanceof Dispatcher &&
					((Dispatcher)childws).getChildWorkSheets().size() > 1) {
				row.title = index+")";
			} else 
				row.title = index+") "+childws.getTitle();
			row.subreport = subreports[i];
			
			report.addData( row );
		}
		m_result = report.getReport();
	}
	public void caseDispatcherCase( DispatcherCase node ) {
		// get result of reporting children.
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		// name
		OptionCase oc = node.getOptionCase();
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		
		Iterator it = children.listIterator();
		SubreportDispSequencer report = new SubreportDispSequencer( m_context.getEventManager(), REPORTNAME );
		// description
		String desc = node.getDescription();
		if (!desc.equals(""))
			report.addHeader(desc);
		// produce rows
		for (int i=0; i<subreports.length; ++i) {
			WorkSheet childws = (WorkSheet) it.next();
			SubreportDispSequencer.DataRow row = report.produceDataRow();
			String caseName = oc.getFullCase(i)[1];
			String index = ""+ALPHABETTA.charAt(i);
			row.title = index+") "+caseName;
			row.subreport = subreports[i];
			
			report.addData( row );
		}
		m_result = report.getReport();
	}
	public void caseAssetsRoot0( AssetsRoot0 node ) {
		// get result of reporting children.
		/*
		
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		
		Iterator it = children.listIterator();
		SubreportDispSequencer report = new SubreportDispSequencer( m_context.getEventManager(), REPORTNAME );
		for (int i=0; i<subreports.length; ++i) {
			WorkSheet childws = (WorkSheet) it.next();
			SubreportDispSequencer.DataRow row = report.produceDataRow();
			
			row.title = childws.getTitle();
			row.subreport = subreports[i];
			
			report.addData( row );
		}
		*/
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert subreports.length <= 1 : "An assets root workplace should have a single child";
		if (subreports.length == 1)
			m_result = subreports[0];
	}
	public void caseTransactionsRoot0( TransactionsRoot0 node ) {
		/*
		// get result of reporting children.
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		
		Iterator it = children.listIterator();
		SubreportDispSequencer report = new SubreportDispSequencer( m_context.getEventManager(), REPORTNAME );
		for (int i=0; i<subreports.length; ++i) {
			WorkSheet childws = (WorkSheet) it.next();
			SubreportDispSequencer.DataRow row = report.produceDataRow();
			
			row.title = childws.getTitle();
			row.subreport = subreports[i];
			
			report.addData( row );
		}
		
		m_result = report.getReport();
		*/
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert subreports.length <= 1 : "A transaction root workplace should have a single child";
		if (subreports.length == 1)
			m_result = subreports[0];
	}

	
	public void caseDispatcherBounds(DispatcherBounds node) {
		// get result of reporting children.
		List children = node.getChildWorkSheets();
		SubreportTreeItem[] subreports = recurse( children );
		
		assert children.size() == subreports.length : 
			"Results must have the same dimension as the child count"; 
		
		Iterator it = children.listIterator();
		SubreportDispSequencer report = 
			new SubreportDispSequencer( m_context.getEventManager(), REPORTNAME );
		// Bounds informations
		Money min = node.getLowerBound();
		Money max = node.getUpperBound();
		boolean isUpperBounded = node.getIsUpperBounded();
		StringBuffer boundsInfo = 
			new StringBuffer(Lang.translate ("Minimal perceived fee: ")+min);
		if (isUpperBounded) {
			boundsInfo.append("\n"+Lang.translate ("Maximal perceived fee: ")+max);
		}
		SubreportTextOnly titleReport = 
			new SubreportTextOnly(m_context.getEventManager(), 
								  REPORTNAME, boundsInfo.toString());
		SubreportDispSequencer.DataRow titleRow = report.produceDataRow();
		titleRow.subreport = titleReport.getReport();
		titleRow.title = Lang.translate ("Bounded fee: ");
		report.addData(titleRow);
		
		
		for (int i=0; i<subreports.length; ++i) {
			WorkSheet childws = (WorkSheet) it.next();
			SubreportDispSequencer.DataRow row = report.produceDataRow();
			
			row.title = childws.getTitle();
			row.subreport = subreports[i];
			
			report.addData( row );
		}
		
		m_result = report.getReport();
	}

}

